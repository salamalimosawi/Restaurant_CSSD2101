<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DeadlockSafeReservationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Restaurant Management System</a> &gt; <a href="index.source.html" class="el_package">com.university.restaurant.service.concurrent</a> &gt; <span class="el_source">DeadlockSafeReservationService.java</span></div><h1>DeadlockSafeReservationService.java</h1><pre class="source lang-java linenums">package com.university.restaurant.service.concurrent;

import com.university.restaurant.model.reservation.Reservation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Comparator;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;

/**
 * Demonstrates deadlock-safe operations using lock ordering and timeouts.
 * Implements three key deadlock prevention strategies:
 * 1. Consistent lock ordering
 * 2. Lock timeouts
 * 3. Retry with exponential backoff
 */
<span class="fc" id="L18">public class DeadlockSafeReservationService {</span>
    
<span class="fc" id="L20">    private static final Logger log = LoggerFactory.getLogger(DeadlockSafeReservationService.class);</span>
    
    // Lock ordering comparator (consistent global order based on reservation ID)
<span class="fc" id="L23">    private static final Comparator&lt;Reservation&gt; LOCK_ORDER = </span>
<span class="fc" id="L24">        Comparator.comparing(r -&gt; r.getId().toString());</span>

    /**
     * Transfer reservation between tables using consistent lock ordering.
     * This prevents deadlock by always acquiring locks in the same order.
     * 
     * @param from First reservation
     * @param to Second reservation
     * @param fromLock Lock for first reservation
     * @param toLock Lock for second reservation
     */
    public void transferReservation(Reservation from, Reservation to, 
                                   Lock fromLock, Lock toLock) {
        // Determine lock acquisition order based on reservation IDs
        Lock firstLock, secondLock;
        
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (LOCK_ORDER.compare(from, to) &lt; 0) {</span>
            // from has lower ID, acquire its lock first
<span class="fc" id="L42">            firstLock = fromLock;</span>
<span class="fc" id="L43">            secondLock = toLock;</span>
        } else {
            // to has lower ID, acquire its lock first
<span class="fc" id="L46">            firstLock = toLock;</span>
<span class="fc" id="L47">            secondLock = fromLock;</span>
        }

        // Acquire locks in consistent order
<span class="fc" id="L51">        firstLock.lock();</span>
        try {
<span class="fc" id="L53">            secondLock.lock();</span>
            try {
                // Safe to modify both reservations - no deadlock possible
<span class="fc" id="L56">                log.info(&quot;Transferred reservation from {} to {}&quot;, from.getId(), to.getId());</span>
                // Actual transfer logic would go here
            } finally {
<span class="fc" id="L59">                secondLock.unlock();</span>
            }
        } finally {
<span class="fc" id="L62">            firstLock.unlock();</span>
        }
<span class="fc" id="L64">    }</span>

    /**
     * Try to acquire lock with timeout to avoid indefinite waiting.
     * Returns false if lock cannot be acquired within timeout period.
     * 
     * @param reservation The reservation to lock
     * @param lock The lock to acquire
     * @param timeout How long to wait
     * @param unit Time unit for timeout
     * @return true if lock acquired and operation succeeded, false otherwise
     */
    public boolean tryReserveWithTimeout(Reservation reservation, Lock lock, 
                                        long timeout, TimeUnit unit) {
        try {
            // Try to acquire lock with timeout
<span class="fc bfc" id="L80" title="All 2 branches covered.">            if (lock.tryLock(timeout, unit)) {</span>
                try {
                    // Perform reservation operation
<span class="fc" id="L83">                    log.info(&quot;Reserved {}&quot;, reservation.getId());</span>
<span class="fc" id="L84">                    return true;</span>
                } finally {
<span class="fc" id="L86">                    lock.unlock();</span>
                }
            } else {
                // Timeout occurred
<span class="fc" id="L90">                log.warn(&quot;Timeout acquiring lock for reservation {}&quot;, reservation.getId());</span>
<span class="fc" id="L91">                return false;</span>
            }
<span class="nc" id="L93">        } catch (InterruptedException e) {</span>
<span class="nc" id="L94">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L95">            log.error(&quot;Interrupted while waiting for lock: {}&quot;, reservation.getId());</span>
<span class="nc" id="L96">            return false;</span>
        }
    }

    /**
     * Retry mechanism with exponential backoff.
     * Attempts to acquire lock multiple times with increasing wait periods.
     * 
     * @param reservation The reservation to process
     * @param lock The lock to acquire
     * @param maxRetries Maximum number of retry attempts
     * @return true if operation succeeded, false if all retries exhausted
     */
    public boolean reserveWithRetry(Reservation reservation, Lock lock, int maxRetries) {
<span class="fc" id="L110">        int attempts = 0;</span>
<span class="fc" id="L111">        long backoffMs = 100; // Start with 100ms</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        while (attempts &lt; maxRetries) {</span>
            try {
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (lock.tryLock(backoffMs, TimeUnit.MILLISECONDS)) {</span>
                    try {
                        // Success!
<span class="fc" id="L118">                        log.info(&quot;Reserved {} after {} attempts&quot;, </span>
<span class="fc" id="L119">                                reservation.getId(), attempts + 1);</span>
<span class="fc" id="L120">                        return true;</span>
                    } finally {
<span class="fc" id="L122">                        lock.unlock();</span>
                    }
                }
<span class="nc" id="L125">            } catch (InterruptedException e) {</span>
<span class="nc" id="L126">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L127">                log.error(&quot;Interrupted during retry for {}&quot;, reservation.getId());</span>
<span class="nc" id="L128">                return false;</span>
<span class="fc" id="L129">            }</span>

            // Failed to acquire lock, prepare for retry
<span class="fc" id="L132">            attempts++;</span>
<span class="fc" id="L133">            backoffMs *= 2; // Exponential backoff: 100ms, 200ms, 400ms, 800ms...</span>
            
<span class="fc" id="L135">            log.warn(&quot;Retry attempt {} for reservation {} (waiting {}ms)&quot;, </span>
<span class="fc" id="L136">                    attempts, reservation.getId(), backoffMs);</span>
        }

        // All retries exhausted
<span class="nc" id="L140">        log.error(&quot;Failed to reserve {} after {} attempts&quot;, </span>
<span class="nc" id="L141">                reservation.getId(), maxRetries);</span>
<span class="nc" id="L142">        return false;</span>
    }

    /**
     * Lock ordering helper for tables.
     * Always acquires table locks in ascending table number order.
     * 
     * @param table1Number First table number
     * @param table2Number Second table number
     * @param lock1 Lock for first table
     * @param lock2 Lock for second table
     * @param operation Runnable to execute while both locks are held
     */
    public void withOrderedTableLocks(int table1Number, int table2Number,
                                     Lock lock1, Lock lock2,
                                     Runnable operation) {
        Lock firstLock, secondLock;
        
        // Always acquire locks in ascending table number order
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (table1Number &lt; table2Number) {</span>
<span class="fc" id="L162">            firstLock = lock1;</span>
<span class="fc" id="L163">            secondLock = lock2;</span>
        } else {
<span class="fc" id="L165">            firstLock = lock2;</span>
<span class="fc" id="L166">            secondLock = lock1;</span>
        }

<span class="fc" id="L169">        firstLock.lock();</span>
        try {
<span class="fc" id="L171">            secondLock.lock();</span>
            try {
<span class="fc" id="L173">                operation.run();</span>
            } finally {
<span class="fc" id="L175">                secondLock.unlock();</span>
            }
        } finally {
<span class="fc" id="L178">            firstLock.unlock();</span>
        }
<span class="fc" id="L180">    }</span>

    /**
     * Try-lock with timeout for multiple resources.
     * Acquires all locks or none, preventing partial acquisition.
     * 
     * @param locks Array of locks to acquire
     * @param timeout Timeout for each lock acquisition
     * @param unit Time unit
     * @param operation Runnable to execute if all locks acquired
     * @return true if operation completed, false if any lock couldn't be acquired
     */
    public boolean tryLockAll(Lock[] locks, long timeout, TimeUnit unit, 
                             Runnable operation) {
<span class="fc" id="L194">        int acquiredCount = 0;</span>
        
        try {
            // Try to acquire all locks
<span class="fc bfc" id="L198" title="All 2 branches covered.">            for (Lock lock : locks) {</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                if (lock.tryLock(timeout, unit)) {</span>
<span class="fc" id="L200">                    acquiredCount++;</span>
                } else {
                    // Failed to acquire this lock
<span class="nc" id="L203">                    log.warn(&quot;Failed to acquire lock {}&quot;, acquiredCount);</span>
<span class="nc" id="L204">                    return false;</span>
                }
            }

            // All locks acquired, perform operation
<span class="fc" id="L209">            operation.run();</span>
<span class="fc" id="L210">            return true;</span>

<span class="nc" id="L212">        } catch (InterruptedException e) {</span>
<span class="nc" id="L213">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L214">            return false;</span>
        } finally {
            // Release all acquired locks in reverse order
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (int i = acquiredCount - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L218">                locks[i].unlock();</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>